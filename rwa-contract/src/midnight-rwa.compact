// Copyright 2025 Brick Towers
pragma language_version 0.18;

import CompactStandardLibrary;
import Crypto;
import PassportIdentity;

export { CoinInfo };
export { ZswapCoinPublicKey };
export { MerkleTreePath };
export { Either };
export { ContractAddress };
export { MerkleTreeDigest };
export { SignedCredential };
export { PassportData };

// We are exporting these signing primitives instead of the pure sign circuit due to broken ecMulGenerator in CompactRuntime
export { computeChallengeForCredential };
export { generateDeterministicK };
// export { sign };

witness localSecretKey(): Bytes<32>;
witness findIssuerPath(pk: Bytes<32>): MerkleTreePath<32, Bytes<32>>;
witness findAuthorizationPath(pk: ZswapCoinPublicKey): MerkleTreePath<32, ZswapCoinPublicKey>;

// Helper witness functions for workarounds
witness reduceChallenge(r: Field): Field;

export ledger counter: Counter;
export ledger nonce: Bytes<32>;
export ledger quizHash: Bytes<32>;
export ledger issuerAuthorizations: HistoricMerkleTree<32, Bytes<32>>;
export ledger authorizations: HistoricMerkleTree<32, ZswapCoinPublicKey>;
export sealed ledger tbtcCoinColor: Bytes<32>;
export sealed ledger identityProviderPublicKey: CurvePoint;
export sealed ledger EIGHTEEN_YEARS_IN_SECONDS: Uint<64>;
export sealed ledger ALLOWED_COUNTRY_CODE1: Field;
export sealed ledger ALLOWED_COUNTRY_CODE2: Field;
export ledger tHF: QualifiedCoinInfo;
export ledger tBTC: QualifiedCoinInfo;

export struct QuizResult {
  q1: Uint<32>;
  q2: Uint<32>;
  q3: Uint<32>;
  q4: Uint<32>;
  q5: Uint<32>;
  q6: Uint<32>;
}

constructor(
  _nonce: Bytes<32>,
  adminIssuer: Bytes<32>,
  _quizHash: Bytes<32>,
  _identityProviderPublicKey: CurvePoint,
  tBTCaddress: ContractAddress
) {
  quizHash = disclose(_quizHash);
  nonce = disclose(_nonce);
  issuerAuthorizations.insert(disclose(adminIssuer));
  identityProviderPublicKey = disclose(_identityProviderPublicKey);
  ALLOWED_COUNTRY_CODE1 = 'UTO' as Field;
  ALLOWED_COUNTRY_CODE2 = 'MID' as Field;
  EIGHTEEN_YEARS_IN_SECONDS = 568036800; // 18 * 365 * 24 * 60 * 60x
  tbtcCoinColor = tokenType(pad(32, "brick-towers:coin:tbtc"), disclose(tBTCaddress));
}

export circuit add(issuer: Bytes<32>): [] {
  checkIfAuthorizedIssuer();
  issuerAuthorizations.insert(disclose(issuer));
}

circuit checkIfAuthorizedIssuer(): [] {
  const key = publicKey(localSecretKey());
  const authPath = findIssuerPath(key);
  const root = merkleTreePathRoot<32, Bytes<32>>(disclose(authPath));
  assert(issuerAuthorizations.checkRoot(root), "not authorized");
}

circuit thfCoinColor(): Bytes<32> {
  return tokenType(pad(32, "brick-towers:coin:thf"), disclose(kernel.self()));
}

export circuit mintTHF(amount: Uint<64>): [] {
  checkIfAuthorizedIssuer();
  const disclosedAmount = disclose(amount);
  counter.increment(1);
  const newNonce = evolveNonce(counter, nonce);
  const destination = right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
  const coin = mintToken(pad(32, "brick-towers:coin:thf"), disclosedAmount, newNonce, destination);
  receive(coin);
  writeTHF(coin);
  nonce = newNonce;
}

export circuit change(sendResult: SendResult): CoinInfo {
  if (sendResult.change.is_some) {
    return sendResult.change.value;
  } else {
    return default<CoinInfo>;
  }
}

circuit writeTBTC(coin: CoinInfo): [] {
  const contractDestination = right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
  if (tBTC != default<QualifiedCoinInfo>) {
    tBTC.writeCoin(mergeCoinImmediate(tBTC, coin), contractDestination);
  } else {
    tBTC.writeCoin(coin, contractDestination);
  }
}

circuit writeTHF(coin: CoinInfo): [] {
  const contractDestination = right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
  if (tHF != default<QualifiedCoinInfo>) {
    tHF.writeCoin(mergeCoinImmediate(tHF, coin), contractDestination);
  } else {
    tHF.writeCoin(coin, contractDestination);
  }
}

export circuit provideTBTC(inputCoin: CoinInfo): [] {
  checkIfAuthorizedIssuer();
  const coin = disclose(inputCoin);
  receive(coin);
  assert(coin.color == tbtcCoinColor, "The coin supplied for verification is not tBTC");
  writeTBTC(coin);
}

export circuit buyTHF(inputCoin: CoinInfo): [] {
  // receive tBTC and send tHF
  isAuthorizedSend(left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
  const coin = disclose(inputCoin);
  assert(coin.color == tbtcCoinColor, "The coin supplied for verification is not tBTC");
  assert(coin.value > 0, "The coin supplied has zero value");
  receive(coin);
  writeTBTC(coin);

  const sendResult = send(tHF, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), coin.value); // respect exchange rate
  const receivedChange = change(sendResult);
  receive(receivedChange);
  const contractDestination = right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
  tHF.writeCoin(receivedChange, contractDestination);
}

export circuit sellTHF(inputCoin: CoinInfo): [] {
  // receive tHF and send tBTC
  const coin = disclose(inputCoin);
  assert(coin.color == thfCoinColor(), "The coin supplied for verification is not tHF");
  assert(coin.value > 0, "The coin supplied has zero value");
  receive(coin);
  writeTHF(coin);

  const sendResult = send(tBTC, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), coin.value); // respect exchange rate
  const receivedChange = change(sendResult);
  receive(receivedChange);
  const contractDestination = right<ZswapCoinPublicKey, ContractAddress>(kernel.self());
  tBTC.writeCoin(receivedChange, contractDestination);
}

circuit assertIdentity(identity: SignedCredential<PassportData>): [] {
  const challenge: Field = reduceChallenge(computeChallengeForCredential(identity.signature.r, identity.pk, identity.credential));
  assert(verify<PassportData>(identity, challenge), "The supplied identity is not signed by the supplied public key");
  assert(identity.pk == identityProviderPublicKey, "The supplied identity is not issued by a trusted identity provider");
  assert(disclose(identity.credential.nationality) == ALLOWED_COUNTRY_CODE1 || disclose(identity.credential.nationality) == ALLOWED_COUNTRY_CODE2, "The holder of the identity is not from an allowed country");
}

circuit assertCoinValue(inputCoin: CoinInfo): [] {
  const coin = disclose(inputCoin);
  assert(coin.color == tbtcCoinColor, "The coin supplied for verification is not tBTC");
  assert(coin.value >= 100, "The coin supplied for verification has a value less than 100 tBTC");
  receive(coin);
  sendImmediate(coin, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()), coin.value);
}

export circuit onboard(quiz: QuizResult, inputCoin: CoinInfo, identity: SignedCredential<PassportData>):[] {
  assert(quizCommit(quiz) == quizHash, "Quiz has some incorrect answers");
  assertIdentity(identity);
  assertCoinValue(inputCoin);
  authorizations.insert(ownPublicKey());
}

// assumed to be called for each send of CoinInfo
export circuit isAuthorizedSend(recipient: Either<ZswapCoinPublicKey, ContractAddress>): [] {
  if (disclose(recipient.is_left)) {
    const authPath = findAuthorizationPath(recipient.left);
    assert(authorizations.checkRoot(merkleTreePathRoot<32, ZswapCoinPublicKey>(disclose(authPath))), "not authorized");
  }
}

export circuit publicKey(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "rwa:pk"), sk]);
}

export pure circuit quizCommit(quizResult: QuizResult): Bytes<32> {
  return persistentCommit<QuizResult>(quizResult, pad(32, "rwa:quiz"));
}