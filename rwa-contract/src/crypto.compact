// Copyright 2025 Brick Towers
pragma language_version >=0.18;

module Crypto {
  import CompactStandardLibrary;

  export struct Challenge {
    r: CurvePoint;
    pk: CurvePoint;
    ch: Field;
  }

  export struct Nonce<T> {
    sk: Field;
    credential: T;
  }

  export struct Signature {
    r: CurvePoint;
    s: Field;
  }

  export struct SignedCredential<T> {
    credential: T;
    signature: Signature;
    pk: CurvePoint;
  }

  export pure circuit derive_pk(sk: Field): CurvePoint {
      const pk: CurvePoint = ecMulGenerator(sk);
      return pk;
  }

  export pure circuit computeChallenge<T>(r: CurvePoint, pk: CurvePoint, credential: T): Field {
    const ch: Field = transientHash<T>(credential);
    const c: Field = transientHash<Challenge>(Challenge {
      r: r,
      pk: pk,
      ch: ch
    });
    return c;
  }

  export pure circuit sign<T>(credential: T, sk: Field): SignedCredential<T> {
    const pk: CurvePoint = ecMulGenerator(sk);
    const k: Field = transientHash<Nonce<T>>(Nonce<T> { sk: sk, credential: credential });
    const r: CurvePoint = ecMulGenerator(k);
    const c: Field = computeChallenge<T>(r, pk, credential);
    const s: Field = k + (c * sk);
    return SignedCredential<T> { credential: credential, signature: Signature { r: r, s: s }, pk: pk };
  }

  export pure circuit deterministicK<T>(nonce: Nonce<T>): Field {
    const k: Field = transientHash<Nonce<T>>(nonce);
    return k;
  }

  export pure circuit verify<T>(credential: SignedCredential<T>, challenge: Field): Boolean {
    const c: Field = challenge;
    const lhs: CurvePoint = ecMulGenerator(credential.signature.s);
    const c_pk =  ecMul(credential.pk, c);
    const rhs: CurvePoint = ecAdd(credential.signature.r, c_pk);
    return lhs == rhs;
  }
}
